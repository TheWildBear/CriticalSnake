<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>CriticalSnake Recorder</title>
  <link rel="stylesheet" href="3rd-party/newcss11/new.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

  <style>
    body {
      margin: 0;
      padding: 0;
      max-width: initial;
      font-family: sans-serif;
      font-size: 1rem;
    }
    div.panel {
      background: #eee;
      padding: 0 5px;
    }
    div.panel > *, div.panel > div > * {
      display: inline-block;
      margin: 5px 0 5px 5px;
    }
    div.panel #intervalField {
      width: 5rem;
    }
    div.panel #urlField {
      width: 15rem;
    }
    pre {
      font-size: 0.5rem;
      border-radius: 0;
      padding: 5px;
      display: none;
    }
  </style>
</head>
<body>
  <div class="panel">
    <button id="nextButton">
      <i id="spinner"></i>
      <label id="nextButtonLabel"></label>
    </button>
    <div>
      <label for="intervalField">Interval (sec):</label>
      <input type="number" id="intervalField" value="30" min="10" max="300">
    </div>
    <div>
      <label for="urlField">Source:</label>
      <input type="text" id="urlField" value="https://api.criticalmaps.net/postv2">
    </div>
  </div>
  <pre id="output"></pre>

  <script src="3rd-party/filesaver20/FileSaver.min.js"></script>
  <script src="3rd-party/lzstring14/lz-string.min.js"></script>

  <script>
    const controls = ["nextButton", "nextButtonLabel", "spinner",
                      "intervalField", "urlField", "output"];

    const panel = {};
    controls.forEach(id => { panel[id] = document.getElementById(id); });

    function setButtonState(state) {
      const spinClasses = ["fa", "fa-spinner", "fa-spin"].join(" ");
      if (state == "Loading") {
        panel.nextButtonLabel.innerText = "";
        panel.spinner.className = spinClasses;
        panel.spinner.style.display = "inline-block";
      } else {
        panel.spinner.style.display = "none";
        panel.spinner.className = spinClasses;
        panel.nextButtonLabel.innerText = state;
      }
    }

    function getButtonState() {
      return panel.nextButtonLabel.innerText || "Loading";
    }

    setButtonState("Record");
    panel.nextButton.addEventListener("click", () => {
      switch (getButtonState()) {
        case "Record":
          panel.intervalField.disabled = true;
          panel.intervalField.style.color = "#888";
          panel.urlField.disabled = true;
          panel.urlField.style.color = "#888";
          panel.output.style.display = "block";
          startRecording(panel.intervalField.value, panel.urlField.value);
          setButtonState("Finish");
          return;
        case "Finish":
          setButtonState("Loading");
          const formattedOutput = finishRecording(panel.output.innerText);
          panel.output.innerText = formattedOutput;
          setButtonState("Download");
          return;
        case "Download":
          setButtonState("Loading");
          const blob = createCompressedBlob(panel.output.innerText);
          setButtonState("Download");
          saveAs(blob, `${formatDate()}_${formatTime()}.recording`);
          return;
        case "Loading":
          console.warn("Please wait until the processed finished");
          return;
      }
    });

    function formatDate(timestamp) {
      const d = timestamp ? new Date(timestamp * 1000) : new Date();
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
    };

    function formatTime(timestamp) {
      const d = timestamp ? new Date(timestamp * 1000) : new Date();
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      return `${pad2(d.getHours())}-${pad2(d.getMinutes())}-${pad2(d.getSeconds())}`
    };

    function print(txt) {
      panel.output.append(txt);
    }

    function appendSnapshot(data) {
      print(`"${formatDate()}_${formatTime()}":{`);
      let goddamntrailingcomma = "";
      for (const hash in data.locations) {
        print(`${goddamntrailingcomma}"${hash}":{` +
          `"timestamp":${data.locations[hash].timestamp},` +
          `"latitude":${data.locations[hash].latitude},` +
          `"longitude":${data.locations[hash].longitude}` +
        `}`);
        goddamntrailingcomma = ",";
      }
      print('},\n');
    }

    let fetchTimer = null;
    function startRecording(interval, url) {
      // Make sure the value is in the expected range.
      const min = 15;
      const max = 300;
      const seconds = Math.min(max, Math.max(min, parseInt(interval)));
      console.log("Start recording", url, "with interval:", seconds * 1000);

      fetchData(url);
      fetchTimer = setInterval(() => fetchData(url), seconds * 1000);
    }

    // Expecting a CORS-enabled endpoint, so reponse header should include:
    // { access-control-allow-origin: *, ... }
    function fetchData(url) {
      fetch(url).then(async (response) => {
        if (!response.ok)
          throw response.status;

        const data = await response.json();
        if (!data["locations"] || data["locations"] === {}) {
          console.warn("No locations in response data");
        }
        else {
          // Success
          appendSnapshot(data);
        }
      })
      .catch(err => {
        console.error("Error querying data from", url, ":", err);
      });
    }

    function finishRecording(rawOutput) {
      clearInterval(fetchTimer);

      // Drop trailling comma, wrap in curly braces and parse as JSON.
      const json = JSON.parse("{" + rawOutput.slice(0, -2) + "}");
      console.log("Finished recording. Snapshots:", json);

      // Human-readable format with indentation of 2 spaces.
      return JSON.stringify(json, null, 2);
    }

    function createCompressedBlob(text) {
      const kilobyte = (str) => Math.round((str.length * 2) / 1024);

      console.log("Raw size is:", kilobyte(text), "KB");
      const compressed = LZString.compressToUTF16(text);
      console.log("Compressed size is:", kilobyte(compressed), "KB");

      return new Blob([compressed], {type: "text/plain;charset=utf-16"});
    }
  </script>
</body>
</html>
