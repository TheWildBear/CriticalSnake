<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CriticalSnake Replay</title>
  <style>
    body {
      background: #333;
    }
    pre {
      color: #fff;
    }
    div#osm-map {
      position: absolute;
      left: 0px;
      top: 0px;
      width: 100%;
      height: 100%;
    }
    div.filtered {
      -webkit-filter: grayscale(50%);
      filter: grayscale(50%);
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <link rel="stylesheet" href="3rd-party/leaflet16/leaflet.css">
  <script src="3rd-party/leaflet16/leaflet.js"></script>
  <script src="3rd-party/jquery35/jquery-3.5.1.min.js"></script>
  <!-- <script src="http://maps.stamen.com/js/tile.stamen.js?v1.3.0"></script> -->

  <script src="critical-snake/common.js"></script>
  <script src="critical-snake/marker.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess.js"></script>
  <script src="critical-snake/postprocess-new.js"></script>
  <script src="critical-snake/utils.js"></script>

  <script>
    const params = parseUrlParams(window.location.href);
    const showMarkerColors = Boolean(params["colors"]);

    const baseLayer = L.tileLayer(
      'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
      { attribution:
          '<a href="{0}">{1}</a> | &copy; <a href="{2}">{3}</a>'.format(
            'https://foundation.wikimedia.org/wiki/Maps_Terms_of_Use',
            'Wikimedia maps', 'http://osm.org/copyright', 'OpenStreetMap'
          )
      }
    );

//    let layerUrl = "http://c.tile.stamen.com/watercolor/${z}/${x}/${y}.jpg";
//    const baseLayer = new L.StamenTileLayer("watercolor", {
//      detectRetina: true
//    });

    let bikeMap = createBikeMap(L, baseLayer, {
      showStats: true, showControls: true, showZoom: true
    });

    let markers = createMarkers(L, showMarkerColors);
    bikeMap.createMarker = (loc) => {
      return L.marker(loc.coord, { icon: markers.bySnakeIdx(loc.snake) });
    };

    let playbackFrameIdx = 0;
    let playbackDataset = null;
    bikeMap.playbackButton.click(() => {
      if (playbackDataset) {
        if (isRunning(bikeMap.playbackButton)) {
          pause();
        } else {
          resume();
        }
      }
    });

    $(document).on("input", bikeMap.historySlider, () => {
      if (playbackDataset) {
        playbackFrameIdx = parseInt(bikeMap.historySlider.val());
        refreshView(playbackFrameIdx);
      }
    });

    bikeMap.on("zoomend", () => {
      if (playbackDataset) {
        const px = Math.max(1, bikeMap.getZoom() - 10) * 6;
        markers.updateSize(px);
      }
    });

    const PostProcessor = new CriticalSnake.PostProcessor({
      coordFilter: getCoordFilter("Berlin"),
      trackRestrictions: {
        minDataPoints: 8,
        minTotalDuration: 300,  // seconds
        minTotalDistance: 1000, // meters
        maxGapDuration: 300,    // seconds
        maxGapDistance: 1000,   // meters
      }
    });

    // ----------------------------------------------------

    bikeMap.browseButton.change(function () {
      // Check selection and set visual indication for the loading progress.
      bikeMap.browseButton.hide();
      bikeMap.loadingLabel.text("Loading..");
      bikeMap.loadingLabel.show();

      if (this.files.length == 0)
        return;
      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      // Load and parse the actual file content.
      const reader = new FileReader();
      $(reader).on('load', (event) => {
        try {
          loadRecording(event.target.result);
        }
        catch (ex) {
          console.error("JSON parsing for file", this.files[0].name,
                        "failed with", ex);
        }
      });
      reader.readAsText(this.files[0]);
    });

    function loadRecording(data) {
      const rawDataSet = JSON.parse(data);
      const replayDataset = PostProcessor.renderTracks(rawDataSet);

      console.log("Filtered", PostProcessor.filteredDupes, "duplicate data points");
      console.log("Filtered", PostProcessor.filteredOutOfRange, "data points outside area of interest");

      bikeMap.historySlider.attr({ min: 0, max: 100 });
      bikeMap.historySlider.val(0);

      playbackFrameIdx = 0;
      playbackDataset = replayDataset;
      refreshView(playbackFrameIdx);

      bikeMap.loadingLabel.hide();
      bikeMap.statsLabel.show();
      bikeMap.historySlider.show();
      bikeMap.playbackButton.show();
    }

    // ----------------------------------------------------

    function refreshView(frameIdx) {
      bikeMap.historySlider.val(frameIdx);

      const begin = playbackDataset.timeRange[0].getTime();
      const end = playbackDataset.timeRange[1].getTime();
      const offset = (end - begin) * (frameIdx / 100);
      const d = new Date(begin + offset);

      drawTracks(playbackDataset.tracks, d);

      // Adds a leading "0" for single digit values.
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      bikeMap.statsLabel.text(
        `📅 ${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ` +
        `🕗 ${pad2(d.getHours())}:${pad2(d.getMinutes())} ` +
        `📍🚲 ???`
      );
    }

    // ----------------------------------------------------

    let frameTimer = null;
    const testFPS = 10;
    function resume() {
      bikeMap.playbackButton.val("||");
      frameTimer = setInterval(() => {
        switch (playbackFrameIdx) {
          case 0:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
          case 100:
            clearTimeout(frameTimer);
            refreshView(playbackFrameIdx);
            bikeMap.playbackButton.val("▶");
            playbackFrameIdx = 0;
            break;
          default:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
        }
      }, 1000 / testFPS);
    }

    function pause() {
      bikeMap.playbackButton.val("▶");
      clearTimeout(frameTimer);
    }

    function isRunning(playbackButton) {
      return playbackButton.val() != "▶";
    }

    let trackHeads = L.layerGroup([], { pane: "markerPane" });
    let trackShadows = L.layerGroup([], { pane: "shadowPane" });

    function drawTracks(tracks, maxTimestamp) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(trackShadows);

      trackHeads.clearLayers();
      trackShadows.clearLayers();

      for (let t = 0; t < tracks.length; t++) {
        const coords = tracks[t].filter(frame => frame.stamp <= maxTimestamp);
        const isLastFrame = (coords.length == tracks[t].length);

        if (coords.length > 3 && !isLastFrame)
          trackHeads.addLayer(
            L.polyline(coords.splice(-2, 2), {
              color: `hsl(${t},100%,50%)`,
              opacity: 0.75
            }));

        if (coords.length > 1)
          trackShadows.addLayer(
            L.polyline(coords, {
              color: `rgb(100, 100, 100)`,
              opacity: 0.1
            }));
      }

      trackShadows.addTo(bikeMap);
      trackHeads.addTo(bikeMap);
    }
  </script>
</body>
</html>
