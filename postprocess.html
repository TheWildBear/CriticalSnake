<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CriticalSnake Replay</title>
</head>
<body>
  <div id="osm-map" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;">
  </div>

  <link rel="stylesheet" href="3rd-party/leaflet16/leaflet.css">
  <script src="3rd-party/leaflet16/leaflet.js"></script>
  <script src="3rd-party/leaflet-semicircle20/Semicircle.js"></script>
  <script src="3rd-party/jquery35/jquery-3.5.1.min.js"></script>
  <script src="3rd-party/geodesy11/latlon-spherical.min.js"></script>

  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess-new.js"></script>

  <script>
    function parseUrlParams(url) {
      const regex = /[?&]([^=#]+)=([^&#]*)/g;
      let params = {};
      let match;
      while(match = regex.exec(url)) {
        params[match[1]] = match[2];
      }
      return params;
    }

    const params = parseUrlParams(window.location.href);
    const bikeMap = createBikeMap(L);

    let playbackFrameIdx = 0;
    let playbackDataset = null;
    bikeMap.playbackButton.click(() => {
      if (playbackDataset) {
        if (isRunning(bikeMap.playbackButton)) {
          pause();
        } else {
          resume();
        }
      }
    });

    bikeMap.historySlider.attr({ min: 0, max: 500 });
    $(document).on("input", bikeMap.historySlider, () => {
      if (playbackDataset) {
        playbackFrameIdx = parseInt(bikeMap.historySlider.val());
        refreshView(playbackFrameIdx);
      }
    });

    bikeMap.browseButton.change(function () {
      // Validate selection and set visual indication for the loading progress.
      bikeMap.browseButton.hide();
      bikeMap.loadingLabel.text("Loading..");
      bikeMap.loadingLabel.show();

      if (this.files.length == 0)
        return;
      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      // Load and parse the actual file content.
      const reader = new FileReader();
      $(reader).on('load', (event) => {
        try {
          loadRecording(event.target.result);
        }
        catch (ex) {
          console.error("JSON parsing for file", this.files[0].name,
                        "failed with", ex);
        }
      });
      reader.readAsText(this.files[0]);
    });

    // ----------------------------------------------------

    function loadRecording(data) {
      const PostProcessor = new CriticalSnake.PostProcessor();

      const analyzeTracksBegin = Date.now();
      const rawDataSet = JSON.parse(data);
      const [ tracks, dataPoints ] = PostProcessor.analyzeTracks(rawDataSet);
      console.log("Data-points:", dataPoints);
      console.log("Analyzing tracks took:", Date.now() - analyzeTracksBegin, "ms");

      const detectCirclesBegin = Date.now();
      const circles = PostProcessor.detectCircles(dataPoints);
      console.log("Circles:", circles);
      console.log("Populating circles took:", Date.now() - detectCirclesBegin, "ms");

      const startTime = 1598638200000; // 2020-08-28, 20:10
      const associateSnakesBegin = Date.now();
      const snakes = PostProcessor.associateSnakes(dataPoints, circles, { startTime: startTime });
      console.log("Snakes:", snakes);
      console.log("Associating snakes took:", Date.now() - associateSnakesBegin, "ms");

      const populateTrackSegmentsBegin = Date.now();
      const segments = PostProcessor.populateTrackSegments(dataPoints, tracks, circles);
      console.log("Segments:", segments);
      console.log("Populating track segments took:", Date.now() - populateTrackSegmentsBegin, "ms");

      const minute = 60 * 1000;
      const timeRange = PostProcessor.getTimeRange(circles);
      console.log("Data covers time range\nfrom:", timeRange.begin, "\nto:", timeRange.end);

      playbackDataset = {
        dataPoints: dataPoints,
        circles: circles,
        snakes: snakes,
        tracks: tracks,
        segments: segments,
        begin: timeRange.begin.getTime() - 5 * minute,
        end: timeRange.end.getTime(),
      };

      playbackFrameIdx = 0;
      refreshView(playbackFrameIdx);

      bikeMap.loadingLabel.hide();
      bikeMap.statsLabel.show();
      bikeMap.historySlider.show();
      bikeMap.playbackButton.show();
    }

    function refreshView(frameIdx) {
      const refreshViewBegin = Date.now();
      bikeMap.historySlider.val(frameIdx);

      const duration = playbackDataset.end - playbackDataset.begin;
      const offset = duration * (frameIdx / 500);
      const d = new Date(playbackDataset.begin + offset);

      drawTracks(playbackDataset, d);

      // Adds a leading "0" for single digit values.
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      bikeMap.statsLabel.text(
        `📅 ${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ` +
        `🕗 ${pad2(d.getHours())}:${pad2(d.getMinutes())} ` +
        `📍🚲 ???`
      );

      console.log("Rendering frame took:", Date.now() - refreshViewBegin, "ms");
    }

    // ----------------------------------------------------

    let frameTimer = null;
    let rotatingCollisionCircles = 0;
    const testFPS = 15;
    function resume() {
      console.log("Rendering", testFPS, "FPS (", 1000 / testFPS, "ms per frame)");
      bikeMap.playbackButton.val("||");
      frameTimer = setInterval(() => {
        rotatingCollisionCircles += testFPS;
        switch (playbackFrameIdx) {
          case 0:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
          case 500:
            clearTimeout(frameTimer);
            refreshView(playbackFrameIdx);
            bikeMap.playbackButton.val("▶");
            playbackFrameIdx = 0;
            break;
          default:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
        }
      }, 1000 / testFPS);
    }

    function pause() {
      bikeMap.playbackButton.val("▶");
      clearTimeout(frameTimer);
    }

    function isRunning(playbackButton) {
      return playbackButton.val() != "▶";
    }

    // ----------------------------------------------------

    let trackHeads = L.layerGroup([], { pane: "markerPane" });
    let trackShadows = L.layerGroup([], { pane: "shadowPane" });

    function drawTracks(dataset, stamp) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(trackShadows);

      trackShadows.clearLayers();
      drawShadows(trackShadows, dataset.dataPoints, dataset.segments, stamp);

      trackHeads.clearLayers();
      drawCircles(trackHeads, dataset.circles, stamp);

      trackShadows.addTo(bikeMap);
      trackHeads.addTo(bikeMap);
    }

    function colors(snakeId) {
      if (snakeId == null)
        return "#888";

      const snakeColors = [
        "#c90002", // red
        "#1b3d9f", // blue
        "#ff0099", // pink
        "#8b00ff", // violett
        "#005214", // green
      ];

      if (snakeId >= 0 && snakeId < snakeColors.length)
        return snakeColors[snakeId];

      return "#000";
    }

    function drawShadows(canvas, dataPoints, segments, stamp) {
      const startedAlready = (seg) => seg.first_stamp <= stamp;
      const didNotStartYet = (idx) => !startedAlready(dataPoints[idx]);

      const findEndIndex = (seg) => {
        if (seg.last_stamp <= stamp)
          return -1;
        return seg.dataPointIdxs.findIndex(idx => didNotStartYet(idx));
      };

      for (const segment of segments.filter(startedAlready)) {
        // Draw non-associated track segments?
        if (segment.snakes.length == 0)
          continue;

        // Draw segment entirely or only the first number of data-points.
        const end = findEndIndex(segment);
        const coordIdxs = end < 0 ? segment.dataPointIdxs
                                  : segment.dataPointIdxs.slice(0, end);

        for (const snakeId of segment.snakes) {
          canvas.addLayer(
              L.polyline(coordIdxs.map(idx => dataPoints[idx]), {
                color: colors(snakeId),
                opacity: 0.05
              }));
        }
      }
    }

    function drawCircles(canvas, circles, stamp) {
      const fullCircle = (c) => L.circle(c, {
        color: colors(c.snakes.values().next().value),
        fillOpacity: 0.75,
        radius: 10 * Math.log2(c.dataPointIdxs.length),
        stroke: false,
      });

      const semiCircle = (c, id, from, to) => L.semiCircle(c, {
        color: colors(id),
        fillOpacity: 0.75,
        radius: 10 * Math.log2(c.dataPointIdxs.length),
        startAngle: from,
        stopAngle: to,
        stroke: false,
      });

      const inTime = (c) => c.first_stamp <= stamp && c.last_stamp >= stamp;

      for (const circle of circles.filter(c => inTime(c))) {
        if (circle.snakes.size == 1) {
          canvas.addLayer(fullCircle(circle));
        }
        else {
          let angle = rotatingCollisionCircles;
          const arcSize = 360 / circle.snakes.size;
          for (const id of circle.snakes) {
            canvas.addLayer(semiCircle(circle, id, angle, angle + arcSize));
            angle += arcSize;
          }
        }
      }
    }
  </script>
</body>
</html>
