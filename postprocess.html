<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>CriticalSnake Postprocess</title>

  <link rel="stylesheet" href="3rd-party/nouislider14/nouislider.min.css">
  <link rel="stylesheet" href="3rd-party/leaflet16/leaflet.css">
  <style>
    body {
      font-size: 1rem;
    }
    #osm-map {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }

    /* TODO: We should define these styles from the JS code too */
    .noUi-horizontal .noUi-handle {
      width: 20px;
      height: 20px;
      right: -10px;
      top: -7px;
    }
    .noUi-handle:before {
      background: transparent;
      text-align: center;
      display: block;
      margin-top: -6px;
      margin-left: -9px;
    }
    .noUi-handle:after {
      background: transparent;
    }

    .noUi-horizontal .noUi-handle:before {
      content: "O";
    }
    .noUi-horizontal .noUi-handle-lower:before {
      content: "S";
    }
    .noUi-horizontal .noUi-handle-upper:before {
      content: "E";
    }
    .noUi-horizontal {
      height: 8px;
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <script src="3rd-party/leaflet16/leaflet.js"></script>
  <script src="3rd-party/leaflet-semicircle20/Semicircle.js"></script>
  <script src="3rd-party/jquery35/jquery-3.5.1.min.js"></script>
  <script src="3rd-party/geodesy11/latlon-spherical.min.js"></script>
  <script src="3rd-party/lzstring14/lz-string.min.js"></script>
  <script src="3rd-party/filesaver20/FileSaver.min.js"></script>
  <script src="3rd-party/nouislider14/nouislider.min.js"></script>
  <script src="3rd-party/vanilla-picker/vanilla-picker.min.js"></script>

  <script src="critical-snake/core.js"></script>
  <script src="critical-snake/postprocess.js"></script>
  <script src="critical-snake/playback.js"></script>
  <script src="critical-snake/postprocess-controls.js"></script>
  <script src="critical-snake/playback-controls.js"></script>
  <script src="critical-snake/bikemap.js"></script>

  <script>
    function parseUrlParams(url) {
      const regex = /[?&]([^=#]+)=([^&#]*)/g;
      let params = {};
      let match;
      while(match = regex.exec(url)) {
        params[match[1]] = match[2];
      }
      return params;
    }

    const params = parseUrlParams(window.location.href);
    const bikeMap = createBikeMap(L);
    bikeMap.browseGroup.show();
    bikeMap.loadingGroup.hide();
    bikeMap.statsLabel.hide();

    bikeMap.zoomGroup = new L.Control.Zoom({ position: 'bottomleft' });

    bikeMap.playbackGroup = new L.Control.PlaybackGroup({
      position: 'bottomleft',
      fps: CriticalSnake.PlaybackOptions.fps,
      speedup: CriticalSnake.PlaybackOptions.speedup,
      autoLimitFps: CriticalSnake.PlaybackOptions.autoLimitFps,
      status: CriticalSnake.PlaybackStatus,
    });

    bikeMap.postprocessGroup = new L.Control.PostprocessGroup({
      position: 'topright',
      filterNames: Object.keys(CriticalSnake.FilterBounds),
      snakeColors: CriticalSnake.PlaybackOptions.snakeColors,
    });

    // We use the default zoom controls group, but we add the playback group
    // first, so that it shows up below the zoom group.
    bikeMap.playbackGroup.addTo(bikeMap);
    bikeMap.zoomGroup.addTo(bikeMap);

    const playback = new CriticalSnake.Playback(bikeMap);

    let rawDataset = {};
    let playbackRecording = null;
    let playbackRecordingHash = null;
    bikeMap.browseButton.change(function() {
      // Validate selection and set visual indication for the loading progress.
      bikeMap.browseGroup.hide();
      bikeMap.loadingGroup.show();
      bikeMap.playbackGroup.hide();
      bikeMap.postprocessGroup.remove();

      if (this.files.length == 0)
        return;
      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      // Load and parse the actual file content.
      const reader = new FileReader();
      $(reader).on('load', (event) => {
        try {
          playbackRecording = this.files[0].name;
          const isCompressed = playbackRecording.endsWith(".recording");
          const snapshots = parseSnapshots(event.target.result, isCompressed);

          loadRawTracks(snapshots);
          bikeMap.statsLabel.show();

          restoreOptions();
          resetOptionsForPostprocessGroup(bikeMap.postprocessGroup.options);
          bikeMap.postprocessGroup.addTo(bikeMap);
          bikeMap.postprocessGroup.show();

          bikeMap.playbackGroup.setTimeRange(playback.dataset.begin, playback.dataset.end);
          bikeMap.playbackGroup.show();
        }
        catch (ex) {
          bikeMap.browseGroup.show();
          console.error("JSON parsing for file", this.files[0].name,
                        "failed with", ex);
        }
        bikeMap.loadingGroup.hide();
      });

      // Give the UI a chance to refresh and show the loading state.
      setTimeout(() => reader.readAsText(this.files[0]), 10);
    });

    bikeMap.postprocessGroup.timeRangeChanged = function(timeRange) {
      // Overwrite post-process parameters from control values in the global
      // `CriticalSnake.PostProcessOptions` instead of passing them to the
      // individual functions. It allows users to query and modify them easily
      // from the browser's debug console.
      CriticalSnake.overridePostprocessOptions({
        analyzeTracks: {
          startStamp: timeRange.start,
          endStamp: timeRange.end,
        },
        associateSnakes: {
          startTime: timeRange.origins,
        },
      });
    };

    bikeMap.postprocessGroup.locationFilterChanged = function(val) {
      if (!CriticalSnake.FilterBounds.hasOwnProperty(val)) {
        console.error("Invalid option: unknown filter-bounds", val);
        return;
      }

      console.log("Set data-point filter to", val);
      CriticalSnake.overridePostprocessOptions({
        analyzeTracks: { filterName: val },
      });

      const filterBounds = CriticalSnake.FilterBounds[val];
      bikeMap.panTo(filterBounds.getCenter());

      // Restore and populate options for the location and rebuild post-process
      // controls.
      bikeMap.postprocessGroup.remove();
      restoreOptions(val);
      resetOptionsForPostprocessGroup(bikeMap.postprocessGroup.options);
      bikeMap.postprocessGroup.addTo(bikeMap);
    };

    bikeMap.postprocessGroup.snakeColorChanged = function(idx, color) {
      CriticalSnake.PlaybackOptions.snakeColors[idx] = color;
      refreshView();
    };

    bikeMap.postprocessGroup.storeOptionsClicked = function() {
      // Query existing options.
      const key = "CriticalSnake";
      const val = localStorage.getItem(key);
      const allOpts = val ? JSON.parse(val) : {};

      // Add/overwrite options in the two-level registry (the current
      // recording's hash-code and the name of the location-filter).
      const lev1 = playbackRecordingHash;
      const lev2 = CriticalSnake.PostProcessOptions.analyzeTracks.filterName;

      allOpts[lev1] = allOpts[lev1] || {};
      allOpts[lev1][lev2] = {
        postprocess: CriticalSnake.PostProcessOptions,
        playback: CriticalSnake.PlaybackOptions,
      };

      localStorage.setItem(key, JSON.stringify(allOpts));
      console.log("Stored options for", playbackRecording, `(${lev2}):`,
                  allOpts[lev1][lev2]);
    };

    function restoreOptions(location) {
      const key = "CriticalSnake";
      const val = localStorage.getItem(key);
      const allOpts = val ? JSON.parse(val) : {};

      const lev1 = playbackRecordingHash.toString();
      const lev2 = location || CriticalSnake.PostProcessOptions.analyzeTracks.filterName;

      if (allOpts.hasOwnProperty(lev1) && allOpts[lev1].hasOwnProperty(lev2)) {
        CriticalSnake.overridePostprocessOptions(allOpts[lev1][lev2].postprocess);
        CriticalSnake.overridePlaybackOptions(allOpts[lev1][lev2].playback);
        console.log("Restored options for", playbackRecording, `(${lev2}):`,
                    allOpts[lev1][lev2]);
      } else {
        console.log("No options stored for", playbackRecording, `(${lev2})`);
      }
    }

    function resetOptionsForPostprocessGroup(opts) {
      const postprocess = CriticalSnake.PostProcessOptions;
      const playback = CriticalSnake.PlaybackOptions;

      if (postprocess.analyzeTracks && postprocess.analyzeTracks.filterName) {
        opts.locationFilter = postprocess.analyzeTracks.filterName;
      }

      if (postprocess.analyzeTracks && postprocess.associateSnakes) {
        opts.timeRange = {
          startStamp: postprocess.analyzeTracks.startStamp,
          originsStamp: postprocess.associateSnakes.startTime,
          endStamp: postprocess.analyzeTracks.endStamp,
        };
      }

      if (playback.snakeColors) {
        opts.snakeColors = playback.snakeColors;
      }
    }

    bikeMap.postprocessGroup.postprocessClicked = function() {
      bikeMap.postprocessGroup.hide();
      bikeMap.statsLabel.hide();
      bikeMap.loadingGroup.show();
      bikeMap.playbackGroup.hide();

      // Give the UI a chance to refresh and show the loading state.
      setTimeout(() => {
        try {
          postprocessRecording();

          bikeMap.playbackGroup.setTimeRange(playback.dataset.begin, playback.dataset.end);
          bikeMap.playbackGroup.show();
          bikeMap.statsLabel.show();
        }
        catch (ex) {
          console.error("Postprocessing failed:", ex);
        }
        bikeMap.loadingGroup.hide();
        bikeMap.postprocessGroup.show();
      }, 10);
    };

    bikeMap.playbackGroup.downloadClicked = function() {
      bikeMap.playbackGroup.hide();
      bikeMap.loadingGroup.show();

      // Give the UI a chance to refresh and show the loading state.
      setTimeout(() => {
        const baseName = playbackRecording.endsWith(".json")
                       ? playbackRecording.slice(0, -5)
                       : playbackRecording;

        downloadReplay(baseName + ".replay", {
          begin: playback.dataset.begin,
          end: playback.dataset.end,
          dataPoints: playback.dataset.dataPoints,
          circles: playback.dataset.circles,
          segments: playback.dataset.segments,
          options: CriticalSnake.PlaybackOptions,
        });

        bikeMap.loadingGroup.hide();
        bikeMap.playbackGroup.show();
      }, 10);
    };

    // ----------------------------------------------------

    function decompressDataset(compressedSnapshots) {
      const kilobyte = (str) => Math.round((str.length * 2) / 1024);

      const decompressionBegin = Date.now();
      const content = LZString.decompressFromUTF16(compressedSnapshots);
      console.log("Compressed size is:", kilobyte(compressedSnapshots), "KB");
      console.log("Decompressed size is:", kilobyte(content), "KB");
      console.log("Decompression took:", Date.now() - decompressionBegin, "ms");

      return content;
    }

    function hashCode(content) {
      const it = (hash, val) => (((hash << 5) - hash) + val.charCodeAt(0)) | 0;
      return content.split('').reduce(it, 0);
    }

    function parseSnapshots(content, isCompressed) {
      const decompressed = isCompressed ? decompressDataset(content) : content;
      playbackRecordingHash = hashCode(decompressed);

      const snapshots = JSON.parse(decompressed);

      // This is a temporary fix, because one version of the record page
      // incorrectly applied a JSON.stringify() where it wasn't necessary.
      if (typeof(snapshots) == "string") {
        console.warn("Parsed content is a string still and not a JSON.",
                    "Apparently, content was double-stringified.",
                    "Trying to parse again.", snapshots);
        return JSON.parse(snapshots);
      }

      return snapshots;
    }

    function loadRawTracks(snapshots) {
      const PostProcessor = new CriticalSnake.PostProcessor();

      const loadRawTracksBegin = Date.now();
      const [ dataPoints, tracks, timeRange ] = PostProcessor.loadRawTracks(snapshots);
      console.log("Data-points:", dataPoints);
      console.log("Tracks:", tracks);
      console.log("Loading raw tracks took:", Date.now() - loadRawTracksBegin, "ms");
      console.log("Data covers time range\nfrom:", timeRange.begin, "\nto:", timeRange.end);

      rawDataset.snapshots = snapshots;
      rawDataset.begin = timeRange.begin.getTime();
      rawDataset.end = timeRange.end.getTime();

      const duration = rawDataset.end - rawDataset.begin;
      bikeMap.postprocessGroup.percentToTimestamp = (percent) => {
        const offset = Math.round(duration * parseFloat(percent) / 100);
        return rawDataset.begin + offset;
      };
      bikeMap.postprocessGroup.timestampToPercent = (timestamp) => {
        const offset = (timestamp - rawDataset.begin);
        return (offset / duration) * 100;
      };

      // Allow to playback raw data for convenience
      playback.setDataset({
        dataPoints: dataPoints,
        tracks: tracks,
        begin: rawDataset.begin,
        end: rawDataset.end,
      });

      refreshView(rawDataset.begin);
    };

    function postprocessRecording() {
      const PostProcessor = new CriticalSnake.PostProcessor();

      const analyzeTracksBegin = Date.now();
      const [ tracks, dataPoints ] = PostProcessor.analyzeTracks(rawDataset.snapshots);
      console.log("Data-points:", dataPoints);
      console.log("Analyzing tracks took:", Date.now() - analyzeTracksBegin, "ms");

      const detectCirclesBegin = Date.now();
      const circles = PostProcessor.detectCircles(dataPoints);
      console.log("Circles:", circles);
      console.log("Populating circles took:", Date.now() - detectCirclesBegin, "ms");

      const associateSnakesBegin = Date.now();
      const snakes = PostProcessor.associateSnakes(dataPoints, circles, tracks);
      console.log("Snakes detected by origin:", snakes);
      console.log("Associating snakes took:", Date.now() - associateSnakesBegin, "ms");

      const populateTrackSegmentsBegin = Date.now();
      const segments = PostProcessor.populateTrackSegments(dataPoints, tracks, circles);
      console.log("Segments:", segments);
      console.log("Populating track segments took:", Date.now() - populateTrackSegmentsBegin, "ms");

      const timeRange = PostProcessor.getTimeRange(circles);
      console.log("Data covers time range from/to:\n", timeRange.begin, "\n", timeRange.end);

      playback.setDataset({
        dataPoints: dataPoints,
        circles: circles,
        tracks: tracks,
        segments: segments,
        begin: timeRange.begin.getTime(),
        end: timeRange.end.getTime(),
      });

      refreshView(timeRange.begin.getTime());
    }

    function downloadReplay(filename, json) {
      const kilobyte = (str) => Math.round((str.length * 2) / 1024);

      const text = JSON.stringify(json);
      console.log("Raw size is:", kilobyte(text), "KB");
      const compressed = LZString.compressToUTF16(text);
      console.log("Compressed size is:", kilobyte(compressed), "KB");

      const blob = new Blob([compressed], {type: "text/plain;charset=utf-16"});
      saveAs(blob, filename);
    }

    function refreshView(playbackTime) {
      playbackTime = playbackTime || CriticalSnake.PlaybackStatus.frameTime;

      const refreshViewBegin = Date.now();
      const bikeCount = playback.drawScene(playbackTime);

      // Adds a leading "0" for single digit values.
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      const d = new Date(playbackTime);
      bikeMap.statsLabel.text(
        `📅 ${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ` +
        `🕗 ${pad2(d.getHours())}:${pad2(d.getMinutes())} ` +
        `📍🚲 ${bikeCount}`);

      const diff = Date.now() - refreshViewBegin;
      console.log("Rendering frame took:", Math.round(diff / 10) * 10, "ms");
    }

    // ----------------------------------------------------

    bikeMap.playbackGroup.renderFrame = function(timestamp) {
      refreshView(timestamp);
    }

    bikeMap.playbackGroup.playbackToggled = function(running) {
      if (running) {
        const fps = CriticalSnake.PlaybackOptions.fps;
        const speed = CriticalSnake.PlaybackOptions.speedup;
        console.log(`Replay ${fps}FPS in ${speed}x time-lapse`);
        bikeMap.postprocessGroup.enablePostprocessing(false);
      }
      else {
        bikeMap.postprocessGroup.enablePostprocessing(true);
      }
    }

    // ----------------------------------------------------

    function drawFilterBounds(color, weight, opacity) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(trackShadows);
      trackShadows.clearLayers();

      const opts = {
        color: color || "#f88",
        weight: weight || 1,
        opacity: opacity || 0.5,
      };

      for (const region in CriticalSnake.FilterBounds) {
        const bounds = CriticalSnake.FilterBounds[region];
        console.log("Filter bounds for", region, ":", bounds);
        trackShadows.addLayer(L.rectangle(bounds, opts));
      }

      trackShadows.addTo(bikeMap);
    }
  </script>
</body>
</html>
