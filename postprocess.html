<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CriticalSnake Replay</title>
  <style>
    body {
      background: #333;
    }
    pre {
      color: #fff;
    }
    div#osm-map {
      position: absolute;
      left: 0px;
      top: 0px;
      width: 100%;
      height: 100%;
    }
    div.filtered {
      -webkit-filter: grayscale(50%);
      filter: grayscale(50%);
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <link rel="stylesheet" href="3rd-party/leaflet16/leaflet.css">
  <script src="3rd-party/leaflet16/leaflet.js"></script>
  <script src="3rd-party/jquery35/jquery-3.5.1.min.js"></script>
  <!-- <script src="http://maps.stamen.com/js/tile.stamen.js?v1.3.0"></script> -->

  <script src="critical-snake/common.js"></script>
  <script src="critical-snake/marker.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess.js"></script>
  <script src="critical-snake/postprocess-new.js"></script>
  <script src="critical-snake/utils.js"></script>

  <script>
    const params = parseUrlParams(window.location.href);
    const showMarkerColors = Boolean(params["colors"]);

    const baseLayer = L.tileLayer(
      'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
      { attribution:
          '<a href="{0}">{1}</a> | &copy; <a href="{2}">{3}</a>'.format(
            'https://foundation.wikimedia.org/wiki/Maps_Terms_of_Use',
            'Wikimedia maps', 'http://osm.org/copyright', 'OpenStreetMap'
          )
      }
    );

//    let layerUrl = "http://c.tile.stamen.com/watercolor/${z}/${x}/${y}.jpg";
//    const baseLayer = new L.StamenTileLayer("watercolor", {
//      detectRetina: true
//    });

    let bikeMap = createBikeMap(L, baseLayer, {
      showStats: true, showControls: true, showZoom: true
    });

    let markers = createMarkers(L, showMarkerColors);
    bikeMap.createMarker = (loc) => {
      return L.marker(loc.coord, { icon: markers.bySnakeIdx(loc.snake) });
    };

    let playbackFrameIdx = 0;
    let playbackDataset = null;
    bikeMap.onPlaybackClicked = (playbackButton) => {
      if (isRunning(playbackButton)) {
        pause(playbackButton);
      } else {
        resume(playbackButton);
      }
    };

    bikeMap.onSliderMoved = (sliderElement) => {
      playbackFrameIdx = sliderElement.value;
      refreshView();
    };

    bikeMap.onMapZoomed = (bikeMap) => {
      const px = Math.max(1, bikeMap.getZoom() - 10) * 6;
      markers.updateSize(px);
    };

    const NewStylePostProcess = new CriticalSnake.PostProcessor({
      coordFilter: getCoordFilter("Berlin"),
      trackRestrictions: {
        minDataPoints: 8,
        minTotalDuration: 300,  // seconds
        minTotalDistance: 1000, // meters
        maxGapDuration: 300,    // seconds
        maxGapDistance: 1000,   // meters
      }
    });

    // ----------------------------------------------------

    $("#browse").change(function () {
      $("#browse").hide();
      $("#progress").text("Loading..");
      $("#progress").show();

      if (this.files.length == 0)
        return;

      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      const reader = new FileReader();
      if (this.files[0].name.endsWith("test")) {
        let rawJSONs = [];
        $(reader).on('load', (event) => {
          const lines = event.target.result.split("\n");
          try {
            for (const line of lines) {
              rawJSONs.push(JSON.parse(line));
            }
          }
          catch (ex) {
            if (lines.length == rawJSONs.length + 1) {
              console.assert(lines[lines.length - 1] == "");
              console.log("Received", rawJSONs.length, "frames");
            }
            else {
              console.error("JSON parsing failed on frame", rawJSONs.length,
                            "Can only playback previous ones.");
            }
          }
          playbackDataset = postprocess(rawJSONs, getCoordFilter("Berlin"));
          runDataSet(playbackDataset);
        });
      } else {
        $(reader).on('load', (event) => {
          const lines = event.target.result;
          try {
            const dataset = JSON.parse(lines);
            playbackDataset = NewStylePostProcess.run(dataset);
            console.log("Filtered", NewStylePostProcess.filteredDupes, "duplicate data points");
            console.log("Filtered", NewStylePostProcess.filteredOutOfRange, "data points outside area of interest");

            drawTracks(NewStylePostProcess.tracks);
            runDataSet(playbackDataset);
          }
          catch (ex) {
            console.error("JSON parsing for file", this.files[0].name,
                          "failed with", ex);
          }
        });
      }

      reader.readAsText(this.files[0]);
    });

    // ----------------------------------------------------

    let playbackBeginAction = () => {};
    let playbackEndAction = () => {};
    function refreshView() {
      switch (playbackFrameIdx) {
        case 0:
          playbackBeginAction();
          break;
        case playbackDataset.frames.length:
          playbackEndAction();
          return;
      }

      $("#history")[0].value = playbackFrameIdx;

      let frame = playbackDataset.frames[playbackFrameIdx];
      let trackedBikes = bikeMap.update(frame.locations);

      $("#stats").text("📅 {0} 🕗 {1} 📍🚲 {2}".format(
        toDateUTC(frame.timestamp), toTimeUTC(frame.timestamp), trackedBikes));

      playbackFrameIdx += 1;
    }

    // ----------------------------------------------------

    let frameTimer = null;
    let testFPS = 10;
    function resume(playbackButton) {
      playbackButton.value = "||";
      frameTimer = setInterval(refreshView, 1000 / testFPS);
      playbackBeginAction = () => {
        const snakeBounds = new L.latLngBounds([
          playbackDataset.snakeBounds.min,
          playbackDataset.snakeBounds.max
        ]);

        bikeMap.fitBounds(snakeBounds, { animate: true });
      };
      playbackEndAction = () => {
        clearTimeout(frameTimer);
        $("#playback").attr("value", "▶");
        playbackFrameIdx = 0;
      };
    }

    function pause(playbackButton) {
      playbackButton.value = "▶";
      clearTimeout(frameTimer);
    }

    function isRunning(playbackButton) {
      return playbackButton.value != "▶";
    }

    function runDataSet(playbackDataset) {
      playbackFrameIdx = 0;

      (new L.marker(playbackDataset.origin, { icon: markers.origin })).addTo(bikeMap);
      //(new L.marker(L.latLng(...playbackDataset.snakeBounds.max), { icon: markers[2] })).addTo(bikeMap);

      const snakeBounds = new L.latLngBounds([
        playbackDataset.snakeBounds.min,
        playbackDataset.snakeBounds.max
      ]);

      const zoomLevel = 16;
      bikeMap.flyTo(playbackDataset.origin, zoomLevel, { animate: true });

      $("#progress").hide();
      $("#playback").show();
      let stats = $("#stats");
      const stamp = playbackDataset.frames[0].timestamp;
      stats.text("📅 {0} 🕗 {1}".format(toDateUTC(stamp), toTimeUTC(stamp)));
      stats.css("display", "block");

      let slider = $("#history");
      slider.attr({
        "min": 0,
        "max": playbackDataset.frames.length - 1,
        "value": 0
      });
      slider.show();
    }

    function drawTracks(tracks) {
      for (let t = 0; t < tracks.length; t++) {
        const coords = [];
        for (const coord of tracks[t]) {
          coords.push(L.latLng(coord.lat, coord.lng));
        }
        L.polyline(coords, {
          color: `hsl(${t},100%,50%)`,
          opacity: 0.75
        }).addTo(bikeMap);
      }
    }
  </script>
</body>
</html>
