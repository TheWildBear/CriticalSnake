<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CriticalSnake Replay</title>
  <!--
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/open-fonts@1.1.1/fonts/inter.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
  -->
  <style>
    body {
      background: #333;
    }
    pre {
      color: #fff;
    }
    div#osm-map {
      position: absolute;
      left: 0px;
      top: 0px;
      width: 100%;
      height: 100%;
    }
    div.filtered {
      -webkit-filter: grayscale(50%);
      filter: grayscale(50%);
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <link rel="stylesheet" href="3rd-party/leaflet16/leaflet.css">
  <script src="3rd-party/leaflet16/leaflet.js"></script>
  <script src="3rd-party/leaflet-semicircle20/Semicircle.js"></script>
  <script src="3rd-party/jquery35/jquery-3.5.1.min.js"></script>
  <script src="3rd-party/geodesy11/latlon-spherical.min.js"></script>

  <script src="critical-snake/common.js"></script>
  <script src="critical-snake/marker.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess-new.js"></script>
  <script src="critical-snake/utils.js"></script>

  <script>

    const params = parseUrlParams(window.location.href);
    const showMarkerColors = Boolean(params["colors"]);

    const baseLayer = L.tileLayer(
      'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
      { attribution:
          '<a href="{0}">{1}</a> | &copy; <a href="{2}">{3}</a>'.format(
            'https://foundation.wikimedia.org/wiki/Maps_Terms_of_Use',
            'Wikimedia maps', 'http://osm.org/copyright', 'OpenStreetMap'
          )
      }
    );

    let bikeMap = createBikeMap(L, baseLayer, {
      showStats: true, showControls: true, showZoom: true
    });

    let markers = createMarkers(L, showMarkerColors);
    bikeMap.createMarker = (loc) => {
      return L.marker(loc.coord, { icon: markers.bySnakeIdx(loc.snake) });
    };

    let playbackFrameIdx = 0;
    let playbackDataset = null;
    bikeMap.playbackButton.click(() => {
      if (playbackDataset) {
        if (isRunning(bikeMap.playbackButton)) {
          pause();
        } else {
          resume();
        }
      }
    });

    bikeMap.historySlider.attr({ min: 0, max: 500 });
    $(document).on("input", bikeMap.historySlider, () => {
      if (playbackDataset) {
        playbackFrameIdx = parseInt(bikeMap.historySlider.val());
        refreshView(playbackFrameIdx);
      }
    });

    bikeMap.on("zoomend", () => {
      if (playbackDataset) {
        const px = Math.max(1, bikeMap.getZoom() - 10) * 6;
        markers.updateSize(px);
      }
    });

//    const square = [];
//    square.push(L.latLng(52.500, 13.400));
//    square.push(L.latLng(52.501, 13.400));
//    square.push(L.latLng(52.501, 13.402));
//    square.push(L.latLng(52.500, 13.402));
//    square.push(L.latLng(52.500, 13.400));
//    L.polyline(square, { color: "rgb(255, 0, 0)" }).addTo(bikeMap);
//
//    function getDirection(c1, c2) {
//      const p1 = new LatLon(c1.lat, c1.lng);
//      const p2 = new LatLon(c2.lat, c2.lng);
//      return p1.bearingTo(p2);
//    }
//
//    function getDistance(c1, c2) {
//      const p1 = new LatLon(c1.lat, c1.lng);
//      const p2 = new LatLon(c2.lat, c2.lng);
//      return p1.distanceTo(p2);
//    }
//
//    function getDestination(c, bearing, dist) {
//      const p = new LatLon(c.lat, c.lng);
//      return p.destinationPoint(dist, bearing);
//    }
//
//    const c1 = L.latLng(52.500, 13.410);
//    const c2 = L.latLng(52.501, 13.411);
//    const c3 = L.latLng(52.501, 13.409);
//    const c4 = L.latLng(52.499, 13.409);
//    const c5 = L.latLng(52.499, 13.411);
//    L.circle(c2, {
//      stroke: false,
//      fillColor: `rgb(0, 0, 255)`,
//      fillOpacity: 1,
//      radius: 10,
//    }).addTo(bikeMap);
//    L.circle(c3, {
//      stroke: false,
//      fillColor: `rgb(0, 255, 0)`,
//      fillOpacity: 1,
//      radius: 10,
//    }).addTo(bikeMap);
//    L.circle(c4, {
//      stroke: false,
//      fillColor: `rgb(220, 220, 0)`,
//      fillOpacity: 1,
//      radius: 10,
//    }).addTo(bikeMap);
//    L.circle(c5, {
//      stroke: false,
//      fillColor: `rgb(255, 0, 0)`,
//      fillOpacity: 1,
//      radius: 10,
//    }).addTo(bikeMap);
//
//    const dir2 = getDirection(c1, c2);
//    const dist2 = getDistance(c1, c2);
//    const dest2 = getDestination(c1, dir2, dist2);
//    console.log(dest2);
//    L.polyline([c1, dest2], {
//      color: `rgb(0, 0, 255)`,
//      opacity: 0.75,
//    }).addTo(bikeMap);
//
//    const dir3 = getDirection(c1, c3);
//    const dist3 = getDistance(c1, c3);
//    L.polyline([c1, getDestination(c1, dir3, dist3)], {
//      color: `rgb(0, 255, 0)`,
//      opacity: 0.75,
//    }).addTo(bikeMap);
//
//    const dir4 = getDirection(c1, c4);
//    const dist4 = getDistance(c1, c4);
//    L.polyline([c1, getDestination(c1, dir4, dist4)], {
//      color: `rgb(220, 220, 0)`,
//      opacity: 0.75,
//    }).addTo(bikeMap);
//
//    const dir5 = getDirection(c1, c5);
//    const dist5 = getDistance(c1, c5);
//    L.polyline([c1, getDestination(c1, dir5, dist5)], {
//      color: `rgb(255, 0, 0)`,
//      opacity: 0.75,
//    }).addTo(bikeMap);
//
//    //bikeMap.setView(c1, 17);

    const minute = 60 * 1000;
    const kilometer = 1000;

    const PostProcessor = new CriticalSnake.PostProcessor({
      coordFilter: getCoordFilter("Berlin"),
      trackRestrictions: {
        minDataPoints: 8,
        minTotalDuration: 5 * minute,
        minTotalDistance: 1 * kilometer,
        maxGapDuration: 5 * minute,
        maxGapDistance: 1 * kilometer,
      },
      waiting: {
        minDuration: 10 * minute,
        maxDistanceMoved: 0.5 * kilometer,
      },
      gathering: {
        maxPointToPointDistance: 1 * kilometer,
        windowSize: 10 * minute,
        windowOverlap: 2 * minute,
      },
      route: {
        maxPointToPointDistance: 0.2 * kilometer,
        windowSize: 30 * minute,
        windowOverlap: 10 * minute,
      },
    });

    // ----------------------------------------------------

    bikeMap.browseButton.change(function () {
      // Validate selection and set visual indication for the loading progress.
      bikeMap.browseButton.hide();
      bikeMap.loadingLabel.text("Loading..");
      bikeMap.loadingLabel.show();

      if (this.files.length == 0)
        return;
      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      // Load and parse the actual file content.
      const reader = new FileReader();
      $(reader).on('load', (event) => {
        try {
          loadRecording(event.target.result);
        }
        catch (ex) {
          console.error("JSON parsing for file", this.files[0].name,
                        "failed with", ex);
        }
      });
      reader.readAsText(this.files[0]);
    });

    function loadRecording(data) {
      const analyzeTracksBegin = Date.now();
      const rawDataSet = JSON.parse(data);
      const [ tracks, dataPoints ] = PostProcessor.analyzeTracks(rawDataSet);
      console.log("Data-points:", dataPoints);
      console.log("Analyzing tracks took:", Date.now() - analyzeTracksBegin, "ms");

      console.log("Filtered", PostProcessor.filteredDupes, "duplicate data points");
      console.log("Filtered", PostProcessor.filteredOutOfRange, "data points outside area of interest");

      const detectCirclesBegin = Date.now();
      const circles = PostProcessor.detectCircles(dataPoints);
      console.log("Circles:", circles);
      console.log("Populating circles took:", Date.now() - detectCirclesBegin, "ms");

      const associateSnakesBegin = Date.now();
      const snakes = PostProcessor.associateSnakes(dataPoints, circles);
      console.log("Snakes:", snakes);
      console.log("Associating snakes took:", Date.now() - associateSnakesBegin, "ms");

      const populateTrackSegmentsBegin = Date.now();
      const segments = PostProcessor.populateTrackSegments(dataPoints, tracks, circles);
      console.log("Segments:", segments);
      console.log("Populating track segments took:", Date.now() - populateTrackSegmentsBegin, "ms");

      playbackDataset = {
        dataPoints: dataPoints,
        circles: circles,
        snakes: snakes,
        tracks: tracks,
        segments: segments,
        timeRange: PostProcessor.getTimeRange(circles),
      };

      playbackFrameIdx = 0;
      refreshView(playbackFrameIdx);

      bikeMap.loadingLabel.hide();
      bikeMap.statsLabel.show();
      bikeMap.historySlider.show();
      bikeMap.playbackButton.show();
    }

    // ----------------------------------------------------

    function refreshView(frameIdx) {
      const refreshViewBegin = Date.now();
      bikeMap.historySlider.val(frameIdx);

      const minute = 60 * 1000;
      const begin = playbackDataset.timeRange.begin.getTime() - 5 * minute;
      const end = playbackDataset.timeRange.end.getTime() + 5 * minute;
      const offset = (end - begin) * (frameIdx / 500);
      const d = new Date(begin + offset);

      drawTracks(playbackDataset, d);

      // Adds a leading "0" for single digit values.
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      bikeMap.statsLabel.text(
        `📅 ${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ` +
        `🕗 ${pad2(d.getHours())}:${pad2(d.getMinutes())} ` +
        `📍🚲 ???`
      );

      console.log("Rendering frame took:", Date.now() - refreshViewBegin, "ms");
    }

    // ----------------------------------------------------

    let frameTimer = null;
    const testFPS = 15;
    function resume() {
      console.log("Rendering", testFPS, "FPS (", 1000 / testFPS, "ms per frame)");
      bikeMap.playbackButton.val("||");
      frameTimer = setInterval(() => {
        switch (playbackFrameIdx) {
          case 0:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
          case 500:
            clearTimeout(frameTimer);
            refreshView(playbackFrameIdx);
            bikeMap.playbackButton.val("▶");
            playbackFrameIdx = 0;
            break;
          default:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
        }
      }, 1000 / testFPS);
    }

    function pause() {
      bikeMap.playbackButton.val("▶");
      clearTimeout(frameTimer);
    }

    function isRunning(playbackButton) {
      return playbackButton.val() != "▶";
    }

    let originMarkers = L.layerGroup([], { pane: "markerPane" });
    let trackHeads = L.layerGroup([], { pane: "markerPane" });
    let trackShadows = L.layerGroup([], { pane: "shadowPane" });

    function drawTracks(dataset, stamp) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(originMarkers);
      bikeMap.removeLayer(trackShadows);

      trackHeads.clearLayers();
      originMarkers.clearLayers();
      trackShadows.clearLayers();

      const colors = (snakeId) => {
        if (snakeId == null)
          return "#888";

        const snakeColors = [
          "#c90002", // red
          "#1b3d9f", //
          "#00c9bc", //
          "#ff0099", //
          "#c112e0", //
        ];

        if (snakeId >= 0 && snakeId < snakeColors.length)
          return snakeColors[snakeId];

        return "#000";
      }

//      const nextSegment = (track, begin) => {
//        const joinSets = (snakes, circleIdx) => {
//          for (const snakeId of dataset.circles[circleIdx].snakes)
//            snakes.add(snakeId);
//          return snakes;
//        };
//
//        const snakes = (circles) => {
//          if (circles)
//            return Array.from(circles).reduce(joinSets, new Set());
//          else
//            console.log(circles);
//        };
//
//        const snakesEqual = (a, b) => {
//          if (a.size != b.size)
//            return false;
//          for (const snake of a)
//            if (!b.has(snake))
//              return false;
//          return true;
//        };
//
//        const snakesBegin = snakes(track[begin].circles);
//
//        for (let i = begin + 1; i < track.length - 1; i++) {
//          if (track[i].last_stamp >= stamp)
//            return [track.slice(begin, i + 1), snakesBegin, track.length];
//
//          if (!snakesEqual(snakesBegin, snakes(track[i].circles)))
//            return [track.slice(begin, i + 1), snakesBegin, i];
//        }
//        return [track.slice(begin), new Set(), track.length];
//      };
//
//      let count = 0;
//      for (const track of dataset.tracks) {
//        let trackPointIdx = 0;
//        do {
//          const [segment, snakeIds, nextIdx] = nextSegment(track, trackPointIdx);
//          count++;
//
//          if (segment.length > 1) {
//            if (snakeIds.size == 0) {
//              // draw non-associated track segment
//            }
//            else {
//              for (const snakeId of snakeIds)
//                trackShadows.addLayer(
//                    L.polyline(segment, {
//                      color: colors(snakeId),
//                      opacity: 0.05
//                    }));
//            }
//          }
//
//          trackPointIdx = nextIdx;
//        } while (trackPointIdx < track.length - 1);
//      }
//      console.log("Track segments in frame:", count);


      const startedAlready = (x) => x.first_stamp <= stamp;
      const didNotStartYet = (x) => !startedAlready(x);

      for (const segment of dataset.segments.filter(startedAlready)) {
        if (segment.snakes.length == 0) {
          // Draw non-associated track segments?
        }
        else {
          const end = segment.dataPointIdxs.findIndex(i => didNotStartYet(dataset.dataPoints[i]));
          if (end > 0 || end == -1) {
            const coords = segment.dataPointIdxs.slice(0, end)
                                                .map(idx => dataset.dataPoints[idx]);
            for (const snakeId of segment.snakes) {
              trackShadows.addLayer(
                  L.polyline(coords, {
                    color: colors(snakeId),
                    opacity: 0.05
                  }));
            }
          }
        }
      }

      const options = {
        stroke: false,
        fillOpacity: 0.75,
        fillColor: null,
        radius: null,
      };


      const inTime = (x) => x.first_stamp <= stamp && x.last_stamp >= stamp;

      for (const circle of dataset.circles.filter(x => inTime(x))) {
        options.radius = 10 * Math.log2(circle.dataPointIdxs.length);
        if (circle.snakes.size == 1) {
          const snakeId = circle.snakes.values().next().value;
          options.color = colors(snakeId);
          trackHeads.addLayer(L.circle(circle, options));
        }
        else {
          let angle = 0;
          const arcSize = 360 / circle.snakes.size;
          for (const snakeId of circle.snakes) {
            options.startAngle = angle;
            options.stopAngle = angle + arcSize;
            options.color = colors(snakeId);
            trackHeads.addLayer(L.semiCircle(circle, options));
            angle += arcSize;
          }
        }
      }

      trackShadows.addTo(bikeMap);
      originMarkers.addTo(bikeMap);
      trackHeads.addTo(bikeMap);
    }
  </script>
</body>
</html>
