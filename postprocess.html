<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CriticalSnake Replay</title>
  <style>
    body {
      background: #333;
    }
    pre {
      color: #fff;
    }
    div#osm-map {
      position: absolute;
      left: 0px;
      top: 0px;
      width: 100%;
      height: 100%;
    }
    div.filtered {
      -webkit-filter: grayscale(50%);
      filter: grayscale(50%);
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <link rel="stylesheet" href="3rd-party/leaflet16/leaflet.css">
  <script src="3rd-party/leaflet16/leaflet.js"></script>
  <script src="3rd-party/jquery35/jquery-3.5.1.min.js"></script>
  <script src="3rd-party/geodesy11/latlon-spherical.min.js"></script>

  <script src="critical-snake/common.js"></script>
  <script src="critical-snake/marker.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess-new.js"></script>
  <script src="critical-snake/utils.js"></script>

  <script>

    const params = parseUrlParams(window.location.href);
    const showMarkerColors = Boolean(params["colors"]);

    const baseLayer = L.tileLayer(
      'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
      { attribution:
          '<a href="{0}">{1}</a> | &copy; <a href="{2}">{3}</a>'.format(
            'https://foundation.wikimedia.org/wiki/Maps_Terms_of_Use',
            'Wikimedia maps', 'http://osm.org/copyright', 'OpenStreetMap'
          )
      }
    );

    let bikeMap = createBikeMap(L, baseLayer, {
      showStats: true, showControls: true, showZoom: true
    });

    let markers = createMarkers(L, showMarkerColors);
    bikeMap.createMarker = (loc) => {
      return L.marker(loc.coord, { icon: markers.bySnakeIdx(loc.snake) });
    };

    let playbackFrameIdx = 0;
    let playbackDataset = null;
    bikeMap.playbackButton.click(() => {
      if (playbackDataset) {
        if (isRunning(bikeMap.playbackButton)) {
          pause();
        } else {
          resume();
        }
      }
    });

    $(document).on("input", bikeMap.historySlider, () => {
      if (playbackDataset) {
        playbackFrameIdx = parseInt(bikeMap.historySlider.val());
        refreshView(playbackFrameIdx);
      }
    });

    bikeMap.on("zoomend", () => {
      if (playbackDataset) {
        const px = Math.max(1, bikeMap.getZoom() - 10) * 6;
        markers.updateSize(px);
      }
    });

//    const square = [];
//    square.push(L.latLng(52.500, 13.400));
//    square.push(L.latLng(52.501, 13.400));
//    square.push(L.latLng(52.501, 13.402));
//    square.push(L.latLng(52.500, 13.402));
//    square.push(L.latLng(52.500, 13.400));
//    L.polyline(square, { color: "rgb(255, 0, 0)" }).addTo(bikeMap);
//
//    function getDirection(c1, c2) {
//      const p1 = new LatLon(c1.lat, c1.lng);
//      const p2 = new LatLon(c2.lat, c2.lng);
//      return p1.bearingTo(p2);
//    }
//
//    function getDistance(c1, c2) {
//      const p1 = new LatLon(c1.lat, c1.lng);
//      const p2 = new LatLon(c2.lat, c2.lng);
//      return p1.distanceTo(p2);
//    }
//
//    function getDestination(c, bearing, dist) {
//      const p = new LatLon(c.lat, c.lng);
//      return p.destinationPoint(dist, bearing);
//    }
//
//    const c1 = L.latLng(52.500, 13.410);
//    const c2 = L.latLng(52.501, 13.411);
//    const c3 = L.latLng(52.501, 13.409);
//    const c4 = L.latLng(52.499, 13.409);
//    const c5 = L.latLng(52.499, 13.411);
//    L.circle(c2, {
//      stroke: false,
//      fillColor: `rgb(0, 0, 255)`,
//      fillOpacity: 1,
//      radius: 10,
//    }).addTo(bikeMap);
//    L.circle(c3, {
//      stroke: false,
//      fillColor: `rgb(0, 255, 0)`,
//      fillOpacity: 1,
//      radius: 10,
//    }).addTo(bikeMap);
//    L.circle(c4, {
//      stroke: false,
//      fillColor: `rgb(220, 220, 0)`,
//      fillOpacity: 1,
//      radius: 10,
//    }).addTo(bikeMap);
//    L.circle(c5, {
//      stroke: false,
//      fillColor: `rgb(255, 0, 0)`,
//      fillOpacity: 1,
//      radius: 10,
//    }).addTo(bikeMap);
//
//    const dir2 = getDirection(c1, c2);
//    const dist2 = getDistance(c1, c2);
//    const dest2 = getDestination(c1, dir2, dist2);
//    console.log(dest2);
//    L.polyline([c1, dest2], {
//      color: `rgb(0, 0, 255)`,
//      opacity: 0.75,
//    }).addTo(bikeMap);
//
//    const dir3 = getDirection(c1, c3);
//    const dist3 = getDistance(c1, c3);
//    L.polyline([c1, getDestination(c1, dir3, dist3)], {
//      color: `rgb(0, 255, 0)`,
//      opacity: 0.75,
//    }).addTo(bikeMap);
//
//    const dir4 = getDirection(c1, c4);
//    const dist4 = getDistance(c1, c4);
//    L.polyline([c1, getDestination(c1, dir4, dist4)], {
//      color: `rgb(220, 220, 0)`,
//      opacity: 0.75,
//    }).addTo(bikeMap);
//
//    const dir5 = getDirection(c1, c5);
//    const dist5 = getDistance(c1, c5);
//    L.polyline([c1, getDestination(c1, dir5, dist5)], {
//      color: `rgb(255, 0, 0)`,
//      opacity: 0.75,
//    }).addTo(bikeMap);
//
//    //bikeMap.setView(c1, 17);

    const minute = 60 * 1000;
    const kilometer = 1000;

    const PostProcessor = new CriticalSnake.PostProcessor({
      coordFilter: getCoordFilter("Berlin"),
      trackRestrictions: {
        minDataPoints: 8,
        minTotalDuration: 5 * minute,
        minTotalDistance: 1 * kilometer,
        maxGapDuration: 5 * minute,
        maxGapDistance: 1 * kilometer,
      },
      waiting: {
        minDuration: 10 * minute,
        maxDistanceMoved: 0.5 * kilometer,
      },
      gathering: {
        maxPointToPointDistance: 1 * kilometer,
        windowSize: 10 * minute,
        windowOverlap: 2 * minute,
      },
      route: {
        maxPointToPointDistance: 0.2 * kilometer,
        windowSize: 30 * minute,
        windowOverlap: 10 * minute,
      },
    });

    // ----------------------------------------------------

    bikeMap.browseButton.change(function () {
      // Validate selection and set visual indication for the loading progress.
      bikeMap.browseButton.hide();
      bikeMap.loadingLabel.text("Loading..");
      bikeMap.loadingLabel.show();

      if (this.files.length == 0)
        return;
      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      // Load and parse the actual file content.
      const reader = new FileReader();
      $(reader).on('load', (event) => {
        try {
          loadRecording(event.target.result);
        }
        catch (ex) {
          console.error("JSON parsing for file", this.files[0].name,
                        "failed with", ex);
        }
      });
      reader.readAsText(this.files[0]);
    });

    function loadRecording(data) {
      const rawDataSet = JSON.parse(data);
      const replayBaseData = PostProcessor.renderTracks(rawDataSet);

      console.log("Filtered", PostProcessor.filteredDupes, "duplicate data points");
      console.log("Filtered", PostProcessor.filteredOutOfRange, "data points outside area of interest");

      const replayOrigins = { origins: [] };
//      const replayOrigins = PostProcessor.detectGatheringPoints(replayBaseData.dataPoints);

//      const replayRoutes = { circles: [] };
      const replayRoutes = PostProcessor.detectRoutes2(replayBaseData.dataPoints,
                                                       replayBaseData.tracks,
                                                       replayOrigins.origins);

      bikeMap.historySlider.attr({ min: 0, max: 100 });
      bikeMap.historySlider.val(0);

      console.log(replayBaseData.tracks);
      console.log(replayBaseData.dataPoints);
      console.log(replayOrigins.origins);
      console.log(replayRoutes.circles);
      console.log(replayRoutes.snakes);

      playbackFrameIdx = 0;
      playbackDataset = { ...replayBaseData, ...replayOrigins, ...replayRoutes };
      refreshView(playbackFrameIdx);

      bikeMap.loadingLabel.hide();
      bikeMap.statsLabel.show();
      bikeMap.historySlider.show();
      bikeMap.playbackButton.show();
    }

    // ----------------------------------------------------

    function refreshView(frameIdx) {
      bikeMap.historySlider.val(frameIdx);

      const begin = playbackDataset.timeRange[0].getTime();
      const end = playbackDataset.timeRange[1].getTime();
      const offset = (end - begin) * (frameIdx / 100);
      const d = new Date(begin + offset);

      drawTracks(playbackDataset, d);

      // Adds a leading "0" for single digit values.
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      bikeMap.statsLabel.text(
        `📅 ${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ` +
        `🕗 ${pad2(d.getHours())}:${pad2(d.getMinutes())} ` +
        `📍🚲 ???`
      );
    }

    // ----------------------------------------------------

    let frameTimer = null;
    const testFPS = 3;
    function resume() {
      bikeMap.playbackButton.val("||");
      frameTimer = setInterval(() => {
        switch (playbackFrameIdx) {
          case 0:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
          case 100:
            clearTimeout(frameTimer);
            refreshView(playbackFrameIdx);
            bikeMap.playbackButton.val("▶");
            playbackFrameIdx = 0;
            break;
          default:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
        }
      }, 1000 / testFPS);
    }

    function pause() {
      bikeMap.playbackButton.val("▶");
      clearTimeout(frameTimer);
    }

    function isRunning(playbackButton) {
      return playbackButton.val() != "▶";
    }

    let originMarkers = L.layerGroup([], { pane: "markerPane" });
    let trackHeads = L.layerGroup([], { pane: "markerPane" });
    let trackShadows = L.layerGroup([], { pane: "shadowPane" });

    function drawTracks(dataset, stamp) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(originMarkers);
      bikeMap.removeLayer(trackShadows);

      trackHeads.clearLayers();
      originMarkers.clearLayers();
      trackShadows.clearLayers();

      const colors = [ "#c90002", "#1b3d9f", "#00c9bc", "#ff0099", "#c112e0",
                       "#000", "#000", "#000", "#000", "#000", "#000", "#000",
                       "#000", "#000", "#000", "#000", "#000", "#000", "#000",
                       "#000", "#000", "#000", "#000", "#000", "#000", "#000",
                       "#000", "#000", "#000", "#000", "#000", "#000", "#000" ];

      const inTime = (x) => x.first_stamp <= stamp && x.last_stamp >= stamp;

      const nextSegment = (track, begin, snakeId) => {
        for (let i = begin + 1; i < track.length; i++) {
          if (track[i].last_stamp >= stamp)
            return [track.slice(begin, i), track.length, snakeId];
          if (track[i].snake != snakeId)
            return [track.slice(begin, i), i, track[i].snake];
        }
        return [track.slice(begin), track.length, null];
      };

      for (const track of dataset.tracks) {
        let segment = [];
        let snakeId = null;
        let dataPointIdx = 1;

        while (dataPointIdx < track.length) {
          const col = snakeId == null ? "#888" : colors[snakeId];
          const group = snakeId == null ? trackShadows : trackHeads;
          [segment, dataPointIdx, snakeId] = nextSegment(track, dataPointIdx, snakeId);

          if (segment.length > 1 && col != "#888")
            group.addLayer(
              L.polyline(segment, {
                color: col,
                opacity: 0.05
              }));
        }
      }

      //for (const circle of dataset.circles) { //.filter(x => inTime(x))) {
      for (const circle of dataset.circles.filter(x => inTime(x))) {
        trackHeads.addLayer(
          L.circle(circle, {
            stroke: false,
            fillColor: circle.snake == null ? "#888" : colors[circle.snake],
            fillOpacity: 0.75,
            radius: 10 * Math.log2(circle.dataPointIdxs.length),
          }));
      }

      for (const origin of dataset.origins.filter(x => inTime(x))) {
        for (const latLng of back(origin.latLngs)) {
          originMarkers.addLayer(
            L.marker(latLng, { icon: markers.origin }));
        }
      }

      trackShadows.addTo(bikeMap);
      originMarkers.addTo(bikeMap);
      trackHeads.addTo(bikeMap);
    }
  </script>
</body>
</html>
