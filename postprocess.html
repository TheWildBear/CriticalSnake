<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CriticalSnake Replay</title>
  <style>
    body {
      background: #333;
    }
    pre {
      color: #fff;
    }
    div#osm-map {
      position: absolute;
      left: 0px;
      top: 0px;
      width: 100%;
      height: 100%;
    }
    div.filtered {
      -webkit-filter: grayscale(50%);
      filter: grayscale(50%);
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <link rel="stylesheet" href="3rd-party/leaflet16/leaflet.css">
  <script src="3rd-party/leaflet16/leaflet.js"></script>
  <script src="3rd-party/jquery35/jquery-3.5.1.min.js"></script>
  <!-- <script src="http://maps.stamen.com/js/tile.stamen.js?v1.3.0"></script> -->

  <script src="critical-snake/common.js"></script>
  <script src="critical-snake/marker.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess-new.js"></script>
  <script src="critical-snake/utils.js"></script>

  <script>
    const params = parseUrlParams(window.location.href);
    const showMarkerColors = Boolean(params["colors"]);

    const baseLayer = L.tileLayer(
      'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
      { attribution:
          '<a href="{0}">{1}</a> | &copy; <a href="{2}">{3}</a>'.format(
            'https://foundation.wikimedia.org/wiki/Maps_Terms_of_Use',
            'Wikimedia maps', 'http://osm.org/copyright', 'OpenStreetMap'
          )
      }
    );

//    let layerUrl = "http://c.tile.stamen.com/watercolor/${z}/${x}/${y}.jpg";
//    const baseLayer = new L.StamenTileLayer("watercolor", {
//      detectRetina: true
//    });

    let bikeMap = createBikeMap(L, baseLayer, {
      showStats: true, showControls: true, showZoom: true
    });

    let markers = createMarkers(L, showMarkerColors);
    bikeMap.createMarker = (loc) => {
      return L.marker(loc.coord, { icon: markers.bySnakeIdx(loc.snake) });
    };

    let playbackFrameIdx = 0;
    let playbackDataset = null;
    bikeMap.playbackButton.click(() => {
      if (playbackDataset) {
        if (isRunning(bikeMap.playbackButton)) {
          pause();
        } else {
          resume();
        }
      }
    });

    $(document).on("input", bikeMap.historySlider, () => {
      if (playbackDataset) {
        playbackFrameIdx = parseInt(bikeMap.historySlider.val());
        refreshView(playbackFrameIdx);
      }
    });

    bikeMap.on("zoomend", () => {
      if (playbackDataset) {
        const px = Math.max(1, bikeMap.getZoom() - 10) * 6;
        markers.updateSize(px);
      }
    });

    const square = [];
    square.push(L.latLng(52.500, 13.400));
    square.push(L.latLng(52.501, 13.400));
    square.push(L.latLng(52.501, 13.402));
    square.push(L.latLng(52.500, 13.402));
    square.push(L.latLng(52.500, 13.400));
    L.polyline(square, { color: "rgb(255, 0, 0)" }).addTo(bikeMap);

    const minute = 60 * 1000;
    const kilometer = 1000;

    const PostProcessor = new CriticalSnake.PostProcessor({
      coordFilter: getCoordFilter("Berlin"),
      trackRestrictions: {
        minDataPoints: 8,
        minTotalDuration: 5 * minute,
        minTotalDistance: 1 * kilometer,
        maxGapDuration: 5 * minute,
        maxGapDistance: 1 * kilometer,
      },
      waiting: {
        minDuration: 10 * minute,
        maxDistanceMoved: 0.5 * kilometer,
      },
      gathering: {
        maxPointToPointDistance: 1 * kilometer,
        windowSize: 10 * minute,
        windowOverlap: 5 * minute,
      },
      route: {
        maxPointToPointDistance: 0.2 * kilometer,
        windowSize: 30 * minute,
        windowOverlap: 10 * minute,
      },
    });

    // ----------------------------------------------------

    bikeMap.browseButton.change(function () {
      // Validate selection and set visual indication for the loading progress.
      bikeMap.browseButton.hide();
      bikeMap.loadingLabel.text("Loading..");
      bikeMap.loadingLabel.show();

      if (this.files.length == 0)
        return;
      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      // Load and parse the actual file content.
      const reader = new FileReader();
      $(reader).on('load', (event) => {
        try {
          loadRecording(event.target.result);
        }
        catch (ex) {
          console.error("JSON parsing for file", this.files[0].name,
                        "failed with", ex);
        }
      });
      reader.readAsText(this.files[0]);
    });

    function loadRecording(data) {
      const rawDataSet = JSON.parse(data);
      const replayBaseData = PostProcessor.renderTracks(rawDataSet);

      console.log("Filtered", PostProcessor.filteredDupes, "duplicate data points");
      console.log("Filtered", PostProcessor.filteredOutOfRange, "data points outside area of interest");

      const replayOrigins = PostProcessor.detectGatheringPoints(replayBaseData.dataPoints);

      const replayRoutes = PostProcessor.detectRoutes2(replayBaseData.dataPoints,
                                                       replayBaseData.tracks,
                                                       replayOrigins.origins);

      bikeMap.historySlider.attr({ min: 0, max: 100 });
      bikeMap.historySlider.val(0);

      console.log(replayBaseData.tracks);
      console.log(replayBaseData.dataPoints);
      console.log(replayOrigins.origins);
      console.log(replayRoutes.circles);

      playbackFrameIdx = 0;
      playbackDataset = { ...replayBaseData, ...replayOrigins, ...replayRoutes };
      refreshView(playbackFrameIdx);

      bikeMap.loadingLabel.hide();
      bikeMap.statsLabel.show();
      bikeMap.historySlider.show();
      bikeMap.playbackButton.show();
    }

    // ----------------------------------------------------

    function refreshView(frameIdx) {
      bikeMap.historySlider.val(frameIdx);

      const begin = playbackDataset.timeRange[0].getTime();
      const end = playbackDataset.timeRange[1].getTime();
      const offset = (end - begin) * (frameIdx / 100);
      const d = new Date(begin + offset);

      drawTracks(playbackDataset, d);

      // Adds a leading "0" for single digit values.
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      bikeMap.statsLabel.text(
        `📅 ${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ` +
        `🕗 ${pad2(d.getHours())}:${pad2(d.getMinutes())} ` +
        `📍🚲 ???`
      );
    }

    // ----------------------------------------------------

    let frameTimer = null;
    const testFPS = 3;
    function resume() {
      bikeMap.playbackButton.val("||");
      frameTimer = setInterval(() => {
        switch (playbackFrameIdx) {
          case 0:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
          case 100:
            clearTimeout(frameTimer);
            refreshView(playbackFrameIdx);
            bikeMap.playbackButton.val("▶");
            playbackFrameIdx = 0;
            break;
          default:
            refreshView(playbackFrameIdx);
            playbackFrameIdx += 1;
            break;
        }
      }, 1000 / testFPS);
    }

    function pause() {
      bikeMap.playbackButton.val("▶");
      clearTimeout(frameTimer);
    }

    function isRunning(playbackButton) {
      return playbackButton.val() != "▶";
    }

    let originMarkers = L.layerGroup([], { pane: "markerPane" });
    let trackHeads = L.layerGroup([], { pane: "markerPane" });
    let trackShadows = L.layerGroup([], { pane: "shadowPane" });

    function drawTracks(dataset, maxStamp) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(originMarkers);
      bikeMap.removeLayer(trackShadows);

      trackHeads.clearLayers();
      originMarkers.clearLayers();
      trackShadows.clearLayers();

      for (let t = 0; t < dataset.tracks.length; t++) {
        const coords = dataset.tracks[t].filter(frame => frame.first_stamp <= maxStamp);
        //const isLastFrame = (coords.length == dataset.tracks[t].length);
        //
        //if (coords.length > 3 && !isLastFrame)
        //  trackHeads.addLayer(
        //    L.polyline(coords.splice(-2, 2), {
        //      color: `hsl(${t},100%,50%)`,
        //      opacity: 0.75
        //    }));

        if (coords.length > 1)
          trackShadows.addLayer(
            L.polyline(coords, {
              color: `rgb(100, 100, 100)`,
              opacity: 0.1
            }));
      }

      for (const circle of dataset.circles) {
        if (circle.first_stamp <= maxStamp && circle.last_stamp >= maxStamp) {
          trackHeads.addLayer(
            L.circle(circle.center, {
              stroke: false,
              fillColor: `rgb(255, 0, 0)`,
              fillOpacity: 0.25,
              radius: 5 * Math.log2(circle.size),
            }));
        }
      }

      const minStamp = new Date(maxStamp.getTime() - 5 * 60 * 1000);
      const inTime = (s) => s.last_stamp >= minStamp && s.first_stamp <= maxStamp;

      for (let s = 0; s < dataset.origins.length; s++) {
        if (inTime(dataset.origins[s])) {
          for (const group of dataset.origins[s].groups) {
            const op = (sum, coord) => L.latLng(sum.lat + coord.lat, sum.lng + coord.lng);
            const sum = group.reduce(op, L.latLng(0, 0));
            const center = L.latLng(sum.lat / group.length, sum.lng / group.length);

            originMarkers.addLayer(
              L.marker(center, { icon: markers.origin }));
          }
        }
      }

      trackShadows.addTo(bikeMap);
      originMarkers.addTo(bikeMap);
      trackHeads.addTo(bikeMap);
    }
  </script>
</body>
</html>
